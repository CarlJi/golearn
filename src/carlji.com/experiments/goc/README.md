# Goc

# 基于go语言的测试覆盖率方式的有趣实现工具，考虑以下场景
	1. 有时候在测试和开发时，可能对某些场景不确定，可能会希望看看执行的结果，多数情况下，大家也许会随机插入一些打印log的代码，然后重新发布后再来测试验证效果，感觉稍显麻烦。
	那针对此场景，如果能绘画出详细的代码执行路径，会不会更好优雅？这样的话，就不用专门去插入无效代码了。
	2. 测试同学也可以借此更方便的查看详细的测试覆盖率
	3. 单元测试也可以有类似场景，比如在go test -cover命令原生支持的情况下，加一个命令-show, 就可以在执行完单测之后，自动打开浏览器，展示覆盖率详细页面

## 设计方案
	1. 提供工具，支持类似go install/build方案，来编译和插桩程序，使用方式: goc compile ./… 【P0】
	2. 就基于go build 命令进行魔改，让其支持参数 cover， covermode， coverpkg， -coverprofile
		○ 如果什么都不加，执行goc build, 默认除vendor库和系统库外，其他的都插桩
		○ 如果加参数支持按要求插桩
	(有个想法，也许可以先自己处理一遍源码(全量插桩，同时添加对外暴露的接口) 之后再调用go build来编译服务
	 好处： 能看到中间过程，方便debug。 同时可以无缝链接go标准工具
	 坏处: 需要两次加载源码，耗时较久。同时处理源码时，要先将其搬到临时目录，那gopath就会变动，gobuild会不会读取上有问题？)	
	3. 插过桩的程序，会自动化暴漏一个端口, 支持将覆盖率结果输出: host:54889/stcover 【P0】
	4. 提供一个客户端工具，在本地配置好gopath的情况下，可以一键生成一个覆盖率的html代码结果，方便本地develop和测试时使用 ，比如goc gen -http://host:54889/stcover【P1】
	5. 支持单测场景，加一个show命令，自动打开浏览器，展示覆盖率详情页面 【P2】

## 使用场景
	1. 通过jenkins or spock编译插桩的包到测试环境， 固定监听一个端口（可以基于配置更改）
	2. 执行测试
	3. 通过goc generate -http=http://10.200.20.22:54889 一键生成一个覆盖率的html页面，来生成代码覆盖率结果，然后就可以通过网页来看效果了
	
## TODOS	
    1. 准备cover stub文件，用于作为插入被测程序的入口
    2. 编写自动插桩工具goc 
    3. goc 集合cover stub文件，编译服务
    4. 提供客户端工具, 自动下载并解析覆盖率结果，生成HTML的覆盖率页面