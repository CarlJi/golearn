
## 前言
前面在[如何负责一个项目的质量保证工作](https://www.cnblogs.com/jinsdu/p/7507887.html)一文中，笔者将质量保障划分为三个阶段，研发质量，上线质量和线上质量。其中针对上线流程，特别提到灰度阶段，QA应该提供相应的验收机制。今天来具体说说
，针对分布式程序如何打造一个方便好用的灰度验收工具。

我们知道，绝大多数分布式程序天然的支持灰度迭代，通过有序的, 分批次的迭代上线，能够有效的控制故障规模，起到发布中验收的效果。但即使这样，如果基础设施不够完善，还是没办法做到无损灰度的。出了问题，实际仍然是有用户感知，只不过范围较小而已。

线上发布，多数是SRE运维同学操作，他们很有可能不清楚业务细节，所以比较欠缺验收手段。多数情况下，发布部署的同学主要依靠查看日志和监控告警手段来验收发布。但其实这非常的被动, 如果是监控告警触发报障，情况可能还好，运维同学会很快感知，快速止损。但如果是客户报障，一来一去时间上可能就会很长，如果稍微影响的客户多些，就是一粒事故。

举个极端例子，比如一个面向用户的接口，因为bug导致用户正常请求在特定场合会返回4xx。如果带着这种bug去恢复，很有可能监控告警层面不会感知，因为4xx在HTTP协议中属于客户端问题，监控告警制定时一般会排除此类code。而客户遇到此类问题，也有可能会首先怀疑自己的行为是否正确，所以到爆发时，影响面就较大了。

然而针对这种用户场景的测试，QA是有验收手段的。
在实际业务迭代中，QA一般都会产出自动化测试，所以就可以通过此类用例，单独对灰度的实例进行验收，确保发布符合预期。

而现实操作中，可能会发现自动化测试用例并不是那么方便去交付别人去使用，有其复杂性，比如：
* 测试框架是基于配置文件来适配不同的测试环境，而让不懂这块的人去改配置，心智成本较高
* 测试有其负责的使用姿势，比如go领域的ginkgo，功能很丰富，可以并发的跑，focus or skip的组合等等
* 实际中，QA可能输出各种类型的用例，比如集成，e2e，或者破坏性的。而破坏性的用例，必须确保不能在线上执行
* 如何准备测试数据，也是需要考量的
* 如何做到测试账号的隔离，来保证线上安全

除了上面的测试本身的复杂性之外，还需要考虑用例的更新机制，以及如何让部署人员方便的拿到我们的测试用例，也就是分发问题。

所以如何降低使用者的心智负担，是该场景下主要考量的问题。



测试服务输出？
是一种服务输出
同时对QA的测试用例要求更高，必须保障稳定。

------