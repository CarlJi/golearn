
## 前言
前面在[如何负责一个项目的质量保证工作](https://www.cnblogs.com/jinsdu/p/7507887.html)一文中，笔者将质量保障划分为三个阶段，研发质量，上线质量和线上质量。其中针对上线流程，特别提到灰度阶段，QA应该提供相应的验收机制。今天来具体说说
，针对分布式程序如何打造一个方便好用的灰度验收工具。

我们知道，绝大多数分布式程序天然的支持灰度迭代，通过有序的分批次的迭代上线，能够有效的控制故障规模，起到发布中验收的效果。但即使这样，如果基础设施不够完善，还是没办法做到无损灰度的。出了问题，实际仍然是有用户感知的，只不过范围较小而已。

线上发布，多数是运维同学操作，他们很有可能不清楚业务细节，所以比较欠缺验收手段。多数情况下，发布部署的同学主要依靠查看日志和监控告警手段来验收发布。但其实这多数是非常的被动等待 - 等待监控报警触发，等待客户报障。当然如果没有，那就认为没问题，接着灰度下一批实例。

这种模式很明显有其问题，如果是监控告警触发报障，情况可能还好，运维同学会很快感知，快速止损。但如果是客户报障，一来一去时间上可能就会很长，如果稍微影响的客户多些，就是一粒小型事故。

举个极端例子，比如一个面向用户的接口，因为bug导致用户正常请求在特定场合会返回4xx。如果带着这种bug去恢复，很有可能监控告警层面不会感知，因为4xx在HTTP协议中属于客户端问题，监控告警制定时一般会排除此类code。而客户遇到此类问题，也有可能会首先怀疑自己的行为是否正确，到爆发时，那影响面就大了。

然而针对这种用户经常的测试，QA就可以做一定的工作，毕竟QA是有验收手段的。
在实际业务迭代中，QA一般都会产出自动化测试，所以只要经常齐全，就可以通过此类用例单独对灰度的实例进行验收，确保发布符合预期。所以QA应该会灰度验收提供帮助，尤其是涉及到产品的e2e场景。

而如何让测试用例更好的服务与线上部署人员又是另一个话题，毕竟是让一个非QA，

QA有验收手段， QA的测试用例分为集测和e2e，破坏性测试等，但e2e的测试只要场景齐全，对我们规范类似问题，非常有帮助。

如何降低测试难度？
API测试框架的复杂性描述：
* 基于配置文件的适配
* 破坏性case的标记
* ginkgo复杂的使用姿势
* 测试数据的准备
* 测试账号的隔离

测试服务输出？
是一种服务输出
同时对QA的测试用例要求更高，必须保障稳定。

------